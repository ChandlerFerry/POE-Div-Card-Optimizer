use std::fs;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};
use std::thread;
use rand::seq::SliceRandom;
use tokio::time::Duration;

#[derive(Serialize, Deserialize, Debug, Clone)]
struct OverlapDetails {
    totalOverlapValue: f64,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Output {
    overlapList: HashMap<String, OverlapDetails>,
    effectiveValue: f64,
}

fn calculate_total_value(combination: &[String], output: &HashMap<String, Output>) -> f64 {
    let mut total_value = 0.0;
    let mut subtract_overlap = 0.0;

    for (idx, map1) in combination.iter().enumerate() {
        total_value += output.get(map1).unwrap().effectiveValue;
        for (jdx, map2) in combination.iter().enumerate() {
            if idx != jdx {
                subtract_overlap += output
                    .get(map1)
                    .unwrap()
                    .overlapList
                    .get(map2)
                    .map_or(0.0, |od| od.totalOverlapValue);
            }
        }
    }

    total_value - subtract_overlap / 2.0
}

fn sample_maps(all_maps: &[String], predefined_groups: &HashMap<&str, Vec<&str>>) -> Vec<String> {
    let mut rng = rand::thread_rng();
    let mut sampled_maps = Vec::new();

    for group in predefined_groups.values() {
        if let Some(selected_map) = group.choose(&mut rng) {
            sampled_maps.push(selected_map.to_string());
        }
    }

    let mut remaining_maps: Vec<&String> = all_maps.iter().filter(|map| !sampled_maps.contains(*map)).collect();
    remaining_maps.shuffle(&mut rng);

    while sampled_maps.len() < 12 {
        if let Some(selected_map) = remaining_maps.pop() {
            sampled_maps.push(selected_map.to_string());
        }
    }

    sampled_maps
}

fn main() {
    let file_path = "./mapCards.json";
    let data = fs::read_to_string(file_path)
        .expect("Unable to read the file");

    let map_cards: HashMap<String, Output> = serde_json::from_str(&data)
        .expect("JSON was not well-formatted");

    let predefined_groups: HashMap<&str, Vec<&str>> = [
        ("group1", vec!["CrimsonTemple", "CrimsonTownship", "DefiledCathedral"]),
        ("group2", vec!["BurialChambers", "Phantasmagoria", "SpiderForest", "WastePool"]),
        ("group3", vec!["Cemetery", "GraveTrough", "Graveyard"]),
        ("group4", vec![
            "AridLake", "Atoll", "BurialChambers", "Canyon", "DesertSpring", "DrySea", 
            "Dunes", "Estuary", "Fields", "JungleValley", "MineralPools", "Orchard", 
            "Plateau", "Shore", "SulphurVents", "Terrace", "TropicalIsland"
        ]),
    ].iter().cloned().collect();

    let output = Arc::new(map_cards);
    let highest_value = Arc::new(Mutex::new((Vec::new(), -1e100)));

    // Spawn threads
    for _ in 0..24 {
        let output_clone = Arc::clone(&output);
        let predefined_groups_clone = predefined_groups.clone();
        let highest_value_clone = Arc::clone(&highest_value);
        thread::spawn(move || {
            let all_maps = output_clone.keys().cloned().collect::<Vec<String>>();
            loop {
                let combo = sample_maps(&all_maps, &predefined_groups_clone);
                let current_value = calculate_total_value(&combo, &output_clone);

                let mut highest = highest_value_clone.lock().unwrap();
                if current_value > highest.1 {
                    *highest = (combo, current_value);
                }
            }
        });
    }

    let mut previous_best_value = -1e100;

    loop {
        thread::sleep(Duration::from_secs(5)); // Check for updates every 5 seconds
        let highest = highest_value.lock().unwrap();

        if highest.1 > previous_best_value {
            println!("New best combination: {:?} with a value of {}", highest.0, highest.1);
            previous_best_value = highest.1;
        }
    }
}
